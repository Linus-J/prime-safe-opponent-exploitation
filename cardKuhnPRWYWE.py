import numpy as np
import random
import copy
import sys
import itertools
import multiprocessing
from scipy.optimize import linprog
import gurobipy as gp
from gurobipy import GRB

class KuhnPoker:
    cards = ['F','E','D','C', 'B', 'A']
    Actions = ['W', 'P'] #Wager or Pass

    @staticmethod
    def terminalState(history):
        return history in ['WW', 'WP', 'PP', 'PWW', 'PWP']

    @staticmethod
    def calcPayoff(history, cards):
        #Get payoff for a player at their accesible point in history
        if history in ['WP', 'PWP']:
            return 1
        else:
            payoff = 2 if 'W' in history else 1
            currentPlayer = len(history) % 2
            currentCard = cards[currentPlayer]
            oppCard = cards[(currentPlayer + 1) % 2]
            if currentCard < oppCard: #Due to the representation used, A is high but since the ascii values are in reverse order then we flip the innequality
                return payoff
            else:
                return -payoff

    @staticmethod
    def payoffWrt(history, cards, wrt):
        #Get payoff for a player at their accesible point in history
        if history in 'WP':
            if wrt == 0:
                return 1
            else:
                return -1
        elif history in 'PWP':
            if wrt == 1:
                return 1
            else:
                return -1
            
        else:
            payoff = 2 if 'W' in history else 1
            currentPlayer = wrt
            currentCard = cards[currentPlayer]
            oppCard = cards[(currentPlayer + 1) % 2]
            if currentCard < oppCard: #Due to the representation used, A is high but since the ascii values are in reverse order then we flip the innequality
                return payoff
            else:
                return -payoff

    @staticmethod
    def deal(players=None):
        deck = KuhnPoker.cards.copy()
        cards = random.choices(deck,k=1) 
        deck.remove(cards[0])
        cards.append(random.choices(deck,k=1)[0])
        if players is not None:
            for player, card in zip(players, cards):
                players[player].card = card
        return cards

class Player:
    def __init__(self, stratProfile=None, card=None):
        self.stratProfile = stratProfile
        self.card = card

    def getAction(self, history):
        return np.random.choice(KuhnPoker.Actions, p=self.stratProfile[self.card+history])

def initBRmatrices():
    kCards = ['A','B','C','D','E','F']
    kActions = ['W', 'P']
    termStates = ['WW', 'WP', 'PP', 'PWW', 'PWP']
    A = np.zeros((25,25))
    count = 0
    for c1 in kCards:
        for c2 in kCards:
            if c2 != c1:
                i = count*4
                j = kCards.index(c2)*4
                A[i+1,j+1] = KuhnPoker.payoffWrt(termStates[0],[c1,c2],0)/30
                A[i+1,j+2] = KuhnPoker.payoffWrt(termStates[1],[c1,c2],0)/30
                A[i+2,j+4] = KuhnPoker.payoffWrt(termStates[2],[c1,c2],0)/30
                A[i+3,j+3] = KuhnPoker.payoffWrt(termStates[3],[c1,c2],0)/30
                A[i+4,j+3] = KuhnPoker.payoffWrt(termStates[4],[c1,c2],0)/30
        count+=1
    
    E = np.zeros((13,25))
    E[0,0]=1
    for i in range(0,6):
        E[i*2+1,i*4+1]=1
        E[i*2+1,i*4+2]=1
        E[i*2+1,0]=-1
        E[i*2+2,i*4+2]=-1
        E[i*2+2,i*4+3]=1
        E[i*2+2,i*4+4]=1

    F = np.zeros((13,25))
    F[0,0]=1
    for i in range(0,6):
        F[i*2+1,i*4+1]=1
        F[i*2+1,i*4+2]=1
        F[i*2+1,0]=-1
        F[i*2+2,0]=-1
        F[i*2+2,i*4+3]=1
        F[i*2+2,i*4+4]=1
    return A,E,F

def epsBR(A, M, playerMap, myMap, epsilon):
    # Pass in A, E or F
    kCards = ['A','B','C','D','E','F']

    y = np.zeros((25,1))
    count = 0
    y[0,0]=1
    for c in kCards:
        y[count+1,0] = playerMap[c+'W'][0]
        y[count+2,0] = playerMap[c+'W'][1]
        y[count+3,0] = playerMap[c+'P'][0]
        y[count+4,0] = playerMap[c+'P'][1]
        count+=4

    x = np.zeros((25,1))
    count = 0
    x[0,0]=1
    for c in kCards:
        x[count+1,0] = myMap[c+''][0]
        x[count+2,0] = myMap[c+''][1]
        x[count+3,0] = myMap[c+'PW'][0]*myMap[c+''][1]
        x[count+4,0] = myMap[c+'PW'][1]*myMap[c+''][1]
        count+=4

    E = M

    F = np.zeros((13,25))
    F[0,0]=1
    for i in range(0,6):
        F[i*2+1,i*4+1]=1
        F[i*2+1,i*4+2]=1
        F[i*2+1,0]=-1
        F[i*2+2,0]=-1
        F[i*2+2,i*4+3]=1
        F[i*2+2,i*4+4]=1

    e = np.zeros((13))
    e[0]=1

    env = gp.Env(empty=True)
    env.setParam("OutputFlag",0)
    env.start()

    m = gp.Model("br",env=env)

    # create variables
    xx = m.addMVar(25, ub=1.0, lb = 0.0)
    q = m.addMVar(13, lb=-float('inf'))

    # create objective
    m.setObjective(np.matmul(A,y).T @ xx, GRB.MAXIMIZE)

    # add constraints
    m.addConstr(E @ xx == e)
    m.addConstr(q[0] == epsilon-V_PRIME)
    m.addConstr(A.T @ xx >= -F.T@q)
    m.addConstr(xx >= 0) 

    m.optimize()
    
    brM = playerMap
    brVector = xx.X

    count = 0
    for c in kCards:
        brM[c+''][0] = abs(brVector[count+1])
        brM[c+''][1] = abs(1-brM[c+''][0]) 
        temp = abs(brM[c+''][1])
        if temp == 0:
            temp = 1
        brM[c+'PW'][0] = abs(brVector[count+3]/temp)
        brM[c+'PW'][1] = abs(1-brM[c+'PW'][0])
        count+=4        
    return brM

def calcMatrices(A, M, playerMap, wrt):
    # Pass in A, E or F
    kCards = ['A','B','C','D','E','F']
    kActions = ['W', 'P']
    termStates = ['WW', 'WP', 'PP', 'PWW', 'PWP']

    if (wrt == 0):
        y = np.zeros((25,1))
        count = 0
        y[0,0]=1
        for c in kCards:
            y[count+1,0] = playerMap[c+'W'][0]
            y[count+2,0] = playerMap[c+'W'][1]
            y[count+3,0] = playerMap[c+'P'][0]
            y[count+4,0] = playerMap[c+'P'][1]
            count+=4
        E = M
        e = np.zeros((13,1))
        e[0,0]=1
        res = linprog(-np.matmul(A,y), A_eq=E, b_eq=e)

        brM = playerMap
        brVector = res.x
        count = 0
        for c in kCards:
            brM[c+''][0] = brVector[count+1]
            brM[c+''][1] = brVector[count+2]
            temp = brVector[count+2]
            if temp == 0:
                temp = 1
            brM[c+'PW'][0] = brVector[count+3]/temp
            brM[c+'PW'][1] = brVector[count+4]/temp
            count+=4
    else:
        B = A
        x = np.zeros((25,1))
        count = 0
        x[0,0]=1

        E = np.zeros((13,25))
        E[0,0]=1
        for i in range(0,6):
            E[i*2+1,i*4+1]=1
            E[i*2+1,i*4+2]=1
            E[i*2+1,0]=-1
            E[i*2+2,i*4+2]=-1
            E[i*2+2,i*4+3]=1
            E[i*2+2,i*4+4]=1

        for c in kCards:
            x[count+1,0] = playerMap[c+''][0]
            x[count+2,0] = playerMap[c+''][1]
            x[count+3,0] = playerMap[c+'PW'][0]*playerMap[c+''][1]
            x[count+4,0] = playerMap[c+'PW'][1]*playerMap[c+''][1]
            count+=4
        F = M
        f = np.zeros((13,1))
        f[0,0]=1
        res = linprog(-np.matmul(np.transpose(B),x), A_eq=F, b_eq=f)

        brM = playerMap
        brVector = res.x

        count = 0
        for c in kCards:
            brM[c+'W'][0] = brVector[count+1]
            brM[c+'W'][1] = brVector[count+2]
            brM[c+'P'][0] = brVector[count+3]
            brM[c+'P'][1] = brVector[count+4]
            count+=4    
    return brM

def calcEv(p1Strat, p2Strat, cards, history, currentPlayer):
    if KuhnPoker.terminalState(history):
        return KuhnPoker.calcPayoff(history, cards)
    currentCard = cards[currentPlayer]
    nextPlayer = (currentPlayer + 1) % 2
    if currentPlayer == 0:
        strat = p1Strat[currentCard + history]
    else:
        strat = p2Strat[currentCard + history]
    nextUtil = np.zeros(len(KuhnPoker.Actions))
    for i,action in enumerate(KuhnPoker.Actions):
        nextUtil[i] = calcEv(p1Strat, p2Strat, cards, history + action, nextPlayer)
    return -np.dot(strat, nextUtil) 

def ev(p1Strat, p2Strat):
    exp = 0
    for c in itertools.permutations(KuhnPoker.cards, 2):
        exp += 1/30 * calcEv(p1Strat, p2Strat, c, '', 0)
    return exp

def testDriver(p1Strat, p2Strat, dynamic, iterations):
    np.random.seed()
    me = Player(p1Strat.copy())
    global V_PRIME, A, E, F
    A,E,F = initBRmatrices()
    V_PRIME = ev(p1Strat,calcMatrices(-A, F, copy.deepcopy(p1Strat), 1))
    ogModel = copy.deepcopy(p1Strat)
    m = copy.deepcopy(p1Strat)
    c = {'F': np.array([0, 0]), 'FW': np.array([0, 0]), \
            'FP': np.array([0, 0]), 'FPW': np.array([0, 0]), \
            'E': np.array([0, 0]), 'EW': np.array([0, 0]), \
            'EP': np.array([0, 0]), 'EPW': np.array([0, 0]), \
            'D': np.array([0, 0]), 'DW': np.array([0, 0]), \
            'DP': np.array([0, 0]), 'DPW': np.array([0, 0]), \
            'C': np.array([0, 0]), 'CW': np.array([0, 0]), \
            'CP': np.array([0, 0]), 'CPW': np.array([0, 0]), \
            'B': np.array([0, 0]), 'BW': np.array([0, 0]), \
            'BP': np.array([0, 0]), 'BPW': np.array([0, 0]), \
            'A': np.array([0, 0]), 'AW': np.array([0, 0]), \
            'AP': np.array([0, 0]), 'APW': np.array([0, 0])}
    me = Player(p1Strat.copy())
    opp = Player(p2Strat.copy())
    model = Player(m.copy())
    players = {1:me, -1:model}
    if (dynamic):
        brStratProfile = calcMatrices(-A, F, copy.deepcopy(p1Strat), 1)
    times = 1000
    totalWinnings = 0
    k = 0
    noExploiting = False
    for i in range(times):
        players = {1:me, -1:model}
        history = ''
        cards = KuhnPoker.deal(players)
        opp.card = cards[1]
        currentPlayer = 1
        while not KuhnPoker.terminalState(history):
            if (dynamic):
                if (i>100):
                    map1 = pi.stratProfile['A']
                    map2 = me.stratProfile['A']
                    if not (map1 == map2).all():
                        opp = Player(calcMatrices(-A, F, copy.deepcopy(pi.stratProfile), 1))
                    else:
                        opp = Player(brStratProfile)
                    opp.card = cards[1]
            if currentPlayer == -1:
                a = opp.getAction(history)
                oppAction = a
            elif noExploiting:
                a = me.getAction(history)
                pi = me
            else:
                pi = Player(epsBR(A, E, copy.deepcopy(model.stratProfile), copy.deepcopy(p1Strat), k)) 
                pi.card = cards[0]
                a = pi.getAction(history)
            currentPlayer = -currentPlayer
            history += a
        oppCard = cards[1]
        key = oppCard + history[0]
        if oppAction == 'P':
            val = 1
        else:
            val = 0
        c[key][val] += 1
        x=5
        updatedAction = [(ogModel[key][0]*x + c[key][0])/(x+sum(c[key])), (ogModel[key][1]*x + c[key][1])/(x+sum(c[key]))]
        model.stratProfile[key] = updatedAction
        tau = calcMatrices(-A, F, copy.deepcopy(pi.stratProfile), 1)
        tau[key] = [1-val,val]
        exp = ev(pi.stratProfile, tau)
        k += exp - V_PRIME
        k = abs(k) #To avoid situations where k≈-0
        payoff = currentPlayer*KuhnPoker.calcPayoff(history, cards)    
        totalWinnings += payoff
    return totalWinnings/times

def multiPro(p1Strat,p2Strat,dynamic):
    n = 40000
    pool = multiprocessing.Pool()
    processes = [pool.apply_async(testDriver, args=(p1Strat, p2Strat, dynamic, iterations),) for iterations in range(1,n+1)]
    result = [p.get() for p in processes]
    totalPayoff = 0
    for i in result:
        totalPayoff+=i
    print(f"Total payoff: {(totalPayoff)/n}")
    print(f"95% Confidence interval: {1.96*(np.std(result))/np.sqrt(n)}")

if __name__ == '__main__':
    np.set_printoptions(precision=6, floatmode='fixed', suppress=True)
    nash = {'F': np.array([0.41641024, 0.58358976]), 'FW': np.array([0.000000, 1.000000]), \
            'FP': np.array([0.83345734, 0.16654266]), 'FPW': np.array([0.000000, 1.000000]), \
            'E': np.array([0.00026377, 0.99973623]), 'EW': np.array([0.08320386, 0.91679614]), \
            'EP': np.array([0.000000, 1.000000]), 'EPW': np.array([0.05637157, 0.94362843]), \
            'D': np.array([0.00031361, 0.99968639]), 'DW': np.array([0.62703124, 0.37296876]), \
            'DP': np.array([0.000000, 1.000000]), 'DPW': np.array([0.69318656, 0.30681344]), \
            'C': np.array([0.000000, 1.000000]), 'CW': np.array([0.62321900, 0.37678100]), \
            'CP': np.array([0.50011406, 0.49988594]), 'CPW': np.array([1.000000, 0.000000]), \
            'B': np.array([0.66974554, 0.33025446]), 'BW': np.array([1.000000, 0.000000]), \
            'BP': np.array([1.000000, 0.000000]), 'BPW': np.array([1.000000, 0.000000]), \
            'A': np.array([0.58046367, 0.41953633]), 'AW': np.array([1.000000, 0.000000]), \
            'AP': np.array([1.000000, 0.000000]), 'APW': np.array([1.000000, 0.000000])}

    closeNash = {'F': np.array([0.34641024, 0.583565358976]), 'FW': np.array([0.050000, 0.950000]), \
            'FP': np.array([0.81345734, 0.18654266]), 'FPW': np.array([0.010000, 0.990000]), \
            'E': np.array([0.08026377, 0.91973623]), 'EW': np.array([0.13320386, 0.86679614]), \
            'EP': np.array([0.020000, 0.980000]), 'EPW': np.array([0.15637157, 0.84362843]), \
            'D': np.array([0.07031361, 0.92968639]), 'DW': np.array([0.60703124, 0.39296876]), \
            'DP': np.array([0.100000, 0.900000]), 'DPW': np.array([0.61318656, 0.38681344]), \
            'C': np.array([0.030000, 0.970000]), 'CW': np.array([0.61321900, 0.38678100]), \
            'CP': np.array([0.60011406, 0.39988594]), 'CPW': np.array([0.010000, 0.990000]), \
            'B': np.array([0.59974554, 0.40025446]), 'BW': np.array([0.910000, 0.090000]), \
            'BP': np.array([0.970000, 0.030000]), 'BPW': np.array([0.970000, 0.030000]), \
            'A': np.array([0.55046367, 0.44953633]), 'AW': np.array([0.930000, 0.070000]), \
            'AP': np.array([0.950000, 0.050000]), 'APW': np.array([0.930000, 0.070000])}

    fiveCardNash = {'F': np.array([0.344603, 0.655397]), 'FW': np.array([0.000000, 1.000000]), \
            'FP': np.array([0.665816, 0.334184]), 'FPW': np.array([0.000000, 1.000000]), \
            'E': np.array([0.003382, 0.996618]), 'EW': np.array([0.118362, 0.881638]), \
            'EP': np.array([0.000000, 1.000000]), 'EPW': np.array([0.479191, 0.520809]), \
            'D': np.array([0.000004, 0.999996]), 'DW': np.array([0.550987, 0.449013]), \
            'DP': np.array([0.000000, 1.000000]), 'DPW': np.array([0.532545, 0.467455]), \
            'C': np.array([0.000004, 0.999996]), 'CW': np.array([0.550987, 0.449013]), \
            'CP': np.array([0.000000, 1.000000]), 'CPW': np.array([0.532545, 0.467455]), \
            'B': np.array([0.211872, 0.788128]), 'BW': np.array([1.000000, 0.000000]), \
            'BP': np.array([1.000000, 0.000000]), 'BPW': np.array([1.000000, 0.000000]), \
            'A': np.array([0.824597, 0.175403]), 'AW': np.array([1.000000, 0.000000]), \
            'AP': np.array([1.000000, 0.000000]), 'APW': np.array([1.000000, 0.000000])}

    fourCardNash = {'F': np.array([0.249847, 0.750153]), 'FW': np.array([0.000000, 1.000000]), \
            'FP': np.array([0.500174, 0.499826]), 'FPW': np.array([0.000000, 1.000000]), \
            'E': np.array([0.000144, 0.999856]), 'EW': np.array([0.253450, 0.746550]), \
            'EP': np.array([0.000000, 1.000000]), 'EPW': np.array([0.250123, 0.749877]), \
            'D': np.array([0.000144, 0.999856]), 'DW': np.array([0.253450, 0.746550]), \
            'DP': np.array([0.000000, 1.000000]), 'DPW': np.array([0.250123, 0.749877]), \
            'C': np.array([0.000004, 0.999996]), 'CW': np.array([0.746765, 0.253235]), \
            'CP': np.array([0.500955, 0.499045]), 'CPW': np.array([0.999992, 0.000008]), \
            'B': np.array([0.000004, 0.999996]), 'BW': np.array([0.746765, 0.253235]), \
            'BP': np.array([0.500955, 0.499045]), 'BPW': np.array([0.999992, 0.000008]), \
            'A': np.array([0.749922, 0.250078]), 'AW': np.array([1.000000, 0.000000]), \
            'AP': np.array([1.000000, 0.000000]), 'APW': np.array([1.000000, 0.000000])}

    threeCardNash = {'F': np.array([0.100000, 0.900000]), 'FW': np.array([0.000000, 1.000000]), \
            'FP': np.array([1/3, 2/3]), 'FPW': np.array([0.000000, 1.000000]), \
            'E': np.array([0.100000, 0.900000]), 'EW': np.array([0.000000, 1.000000]), \
            'EP': np.array([1/3, 2/3]), 'EPW': np.array([0.000000, 1.000000]), \
            'D': np.array([0.000000, 1.000000]), 'DW': np.array([1/3, 2/3]), \
            'DP': np.array([0.000000, 1.000000]), 'DPW': np.array([.1+1/3, 2/3-.1]), \
            'C': np.array([0.000000, 1.000000]), 'CW': np.array([1/3, 2/3]), \
            'CP': np.array([0.000000, 1.000000]), 'CPW': np.array([.1+1/3, 2/3-.1]), \
            'B': np.array([0.300000, 0.700000]), 'BW': np.array([1.000000, 0.000000]), \
            'BP': np.array([1.000000, 0.000000]), 'BPW': np.array([1.000000, 0.000000]), \
            'A': np.array([0.300000, 0.700000]), 'AW': np.array([1.000000, 0.000000]), \
            'AP': np.array([1.000000, 0.000000]), 'APW': np.array([1.000000, 0.000000])}

    randomStrat = {'F': np.array([0.5, 0.5]), 'FW': np.array([0.5, 0.5]), \
            'FP': np.array([0.5, 0.5]), 'FPW': np.array([0.5, 0.5]), \
            'E': np.array([0.500000, 0.500000]), 'EW': np.array([0.500000, 0.500000]), \
            'EP': np.array([1/2, 1/2]), 'EPW': np.array([0.500000, 0.500000]), \
            'D': np.array([0.500000, 0.500000]), 'DW': np.array([1/2, 1/2]), \
            'DP': np.array([0.500000, 0.500000]), 'DPW': np.array([0.500000, 0.500000]), \
            'C': np.array([0.500000, 0.500000]), 'CW': np.array([0.500000, 0.500000]), \
            'CP': np.array([0.500000, 0.500000]), 'CPW': np.array([0.500000, 0.500000]), \
            'B': np.array([0.500000, 0.500000]), 'BW': np.array([0.500000, 0.500000]), \
            'BP': np.array([0.500000, 0.500000]), 'BPW': np.array([0.500000, 0.500000]), \
            'A': np.array([0.500000, 0.500000]), 'AW': np.array([0.500000, 0.500000]), \
            'AP': np.array([0.500000, 0.500000]), 'APW': np.array([0.500000, 0.500000])}
    
    if (sys.argv[1] == '0'):
        if (sys.argv[2] == '0'):
            multiPro(nash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(nash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(nash, randomStrat, False)
        else:
            multiPro(nash, randomStrat, True)
    elif (sys.argv[1] == '1'):
        if (sys.argv[2] == '0'):
            multiPro(fiveCardNash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(fiveCardNash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(fiveCardNash, randomStrat, False)
        else:
            multiPro(fiveCardNash, randomStrat, True)
    elif (sys.argv[1] == '2' ):
        if (sys.argv[2] == '0'):
            multiPro(fourCardNash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(fourCardNash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(fourCardNash, randomStrat, False)
        else:
            multiPro(fourCardNash, randomStrat, True)
    else:
        if (sys.argv[2] == '0'):
            multiPro(threeCardNash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(threeCardNash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(threeCardNash, randomStrat, False)
        else:
            multiPro(threeCardNash, randomStrat, True)
