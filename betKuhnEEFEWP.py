import numpy as np
import random
import sys
import re
import itertools
import copy
import multiprocessing
from scipy.optimize import linprog
import gurobipy as gp
from gurobipy import GRB

class KuhnPoker:
    cards = ['C', 'B', 'A']
    Actions = ['1','2','3','4','P']

    @staticmethod
    def terminalState(history):
        return history in ['11','22','33','44','1P','2P','3P','4P','PP','P11','P22','P33','P44','P1P','P2P','P3P','P4P'] 

    @staticmethod
    def calcPayoff(history, cards):
        #Get payoff with respect to current player
        if history in ['1P', 'P1P','2P','P2P','3P','P3P','4P','P4P']:
            return 1
        else:
            payoff = 2 if '1' in history else 1
            if '2' in history:
                payoff = 3
            if '3' in history:
                payoff = 4
            if '4' in history:
                payoff = 5
            currentPlayer = len(history) % 2
            currentCard = cards[currentPlayer]
            oppCard = cards[(currentPlayer + 1) % 2]
            if currentCard < oppCard:
                return payoff
            else:
                return -payoff

    @staticmethod
    def payoffWrt(history, cards, wrt):
        #Get payoff with respect to current player
        if history in ['1P','2P','3P','4P']:
            return 1
        if history in ['P1P','P2P','P3P','P4P']:
            return -1
        else:
            payoff = 2 if '1' in history else 1
            if '2' in history:
                payoff = 3
            if '3' in history:
                payoff = 4
            if '4' in history:
                payoff = 5
            currentCard = cards[0]
            oppCard = cards[1]
            if currentCard < oppCard:
                return payoff
            else:
                return -payoff

    @staticmethod
    def deal(players=None):
        deck = KuhnPoker.cards.copy()
        cards = random.choices(deck,k=1) 
        deck.remove(cards[0])
        cards.append(random.choices(deck,k=1)[0])
        if players is not None:
            for player, card in zip(players, cards):
                players[player].card = card
        return cards

class Player:
    def __init__(self, stratProfile=None, card=None):
        self.stratProfile = stratProfile
        self.card = card

    def getAction(self, history):
        try:
            return np.random.choice(KuhnPoker.Actions, p=self.stratProfile[self.card+history])
        except:
            #sometimes the LP solver outputs probabilities of 1.00000002 due to floating point error
            for i in range(0,5):
                self.stratProfile[self.card+history][i] = round(self.stratProfile[self.card+history][i],5)
            return np.random.choice(KuhnPoker.Actions, p=self.stratProfile[self.card+history])

def initBRmatrices(myMap, playerMap):
    kCards = ['A','B','C']
    kActions = ['1','2','3','4','P']
    termStates = ['11','1P','22','2P','33','3P','44','4P','PP','P11','P1P','P22','P2P','P33','P3P','P44','P4P']
    A = np.zeros((40,40))
    count = 0
    for c1 in kCards:
        for c2 in kCards:
            if c2 != c1:
                i = count*13
                j = kCards.index(c2)*13
                A[i+1,j+1] = KuhnPoker.payoffWrt(termStates[0],[c1,c2],0)/6 #11,1P,....,4P
                A[i+1,j+2] = KuhnPoker.payoffWrt(termStates[1],[c1,c2],0)/6
                A[i+2,j+3] = KuhnPoker.payoffWrt(termStates[2],[c1,c2],0)/6
                A[i+2,j+4] = KuhnPoker.payoffWrt(termStates[3],[c1,c2],0)/6
                A[i+3,j+5] = KuhnPoker.payoffWrt(termStates[4],[c1,c2],0)/6
                A[i+3,j+6] = KuhnPoker.payoffWrt(termStates[5],[c1,c2],0)/6
                A[i+4,j+7] = KuhnPoker.payoffWrt(termStates[6],[c1,c2],0)/6
                A[i+4,j+8] = KuhnPoker.payoffWrt(termStates[7],[c1,c2],0)/6

                A[i+5,j+9] = KuhnPoker.payoffWrt(termStates[8],[c1,c2],0)/6 #PP

                A[i+6,j+10] = KuhnPoker.payoffWrt(termStates[9],[c1,c2],0)/6 #P11,P1P,....,P4P
                A[i+7,j+10] = KuhnPoker.payoffWrt(termStates[10],[c1,c2],0)/6
                A[i+8,j+11] = KuhnPoker.payoffWrt(termStates[11],[c1,c2],0)/6
                A[i+9,j+11] = KuhnPoker.payoffWrt(termStates[12],[c1,c2],0)/6
                A[i+10,j+12] = KuhnPoker.payoffWrt(termStates[13],[c1,c2],0)/6
                A[i+11,j+12] = KuhnPoker.payoffWrt(termStates[14],[c1,c2],0)/6
                A[i+12,j+13] = KuhnPoker.payoffWrt(termStates[15],[c1,c2],0)/6
                A[i+13,j+13] = KuhnPoker.payoffWrt(termStates[16],[c1,c2],0)/6
        count+=1

    y = np.zeros((40,1))
    count = 0
    y[0,0]=1
    for c in kCards:
        y[count+1,0] = playerMap[c+'1'][0]
        y[count+2,0] = playerMap[c+'1'][4]
        y[count+3,0] = playerMap[c+'2'][1]
        y[count+4,0] = playerMap[c+'2'][4]
        y[count+5,0] = playerMap[c+'3'][2]
        y[count+6,0] = playerMap[c+'3'][4]
        y[count+7,0] = playerMap[c+'4'][3]
        y[count+8,0] = playerMap[c+'4'][4]
        y[count+9,0] = playerMap[c+'P'][4]
        y[count+10,0] = playerMap[c+'P'][0]
        y[count+11,0] = playerMap[c+'P'][1]
        y[count+12,0] = playerMap[c+'P'][2]
        y[count+13,0] = playerMap[c+'P'][3]
        count+=13

    x = np.zeros((40,1))
    count = 0
    x[0,0]=1
    for c in kCards:
        x[count+1,0] = myMap[c+''][0]
        x[count+2,0] = myMap[c+''][1]
        x[count+3,0] = myMap[c+''][2]
        x[count+4,0] = myMap[c+''][3]
        x[count+5,0] = myMap[c+''][4]
        x[count+6,0] = myMap[c+'P1'][0]*myMap[c+''][4]
        x[count+7,0] = myMap[c+'P1'][4]*myMap[c+''][4]
        x[count+8,0] = myMap[c+'P2'][1]*myMap[c+''][4]
        x[count+9,0] = myMap[c+'P2'][4]*myMap[c+''][4]
        x[count+10,0] = myMap[c+'P3'][2]*myMap[c+''][4]
        x[count+11,0] = myMap[c+'P3'][4]*myMap[c+''][4]
        x[count+12,0] = myMap[c+'P4'][3]*myMap[c+''][4]
        x[count+13,0] = myMap[c+'P4'][4]*myMap[c+''][4]
        count+=13

    E = np.zeros((16,40))
    E[0,0]=1
    for i in range(0,3):
        E[i*5+1,0]=-1
        E[i*5+1,i*13+1]=1 #1
        E[i*5+1,i*13+2]=1
        E[i*5+1,i*13+3]=1
        E[i*5+1,i*13+4]=1
        E[i*5+1,i*13+5]=1 #P
        
        E[i*5+2,i*13+5]=-1
        E[i*5+2,i*13+6]=1 #P11
        E[i*5+2,i*13+7]=1 #P1P
        E[i*5+3,i*13+5]=-1
        E[i*5+3,i*13+8]=1 #P22
        E[i*5+3,i*13+9]=1 #P2P
        E[i*5+4,i*13+5]=-1
        E[i*5+4,i*13+10]=1 #P33
        E[i*5+4,i*13+11]=1 #P3P
        E[i*5+5,i*13+5]=-1
        E[i*5+5,i*13+12]=1 #P44
        E[i*5+5,i*13+13]=1 #P4P

    F = np.zeros((16,40))
    F[0,0]=1
    for i in range(0,3):
        F[i*5+1,0]=-1
        F[i*5+2,0]=-1
        F[i*5+3,0]=-1
        F[i*5+4,0]=-1
        F[i*5+5,0]=-1
        F[i*5+1,i*13+1]=1
        F[i*5+1,i*13+2]=1
        F[i*5+2,i*13+3]=1
        F[i*5+2,i*13+4]=1
        F[i*5+3,i*13+5]=1
        F[i*5+3,i*13+6]=1
        F[i*5+4,i*13+7]=1
        F[i*5+4,i*13+8]=1

        F[i*5+5,i*13+9]=1
        F[i*5+5,i*13+10]=1
        F[i*5+5,i*13+11]=1
        F[i*5+5,i*13+12]=1
        F[i*5+5,i*13+13]=1
        
    return A,E,F

def epsBR(A, E, F, playerMap, myMap, epsilon):
    # Pass in A, E or F
    kCards = ['A','B','C']
    brM = playerMap
    y = np.zeros((40,1))
    count = 0
    y[0,0]=1
    for c in kCards:
        y[count+1,0] = playerMap[c+'1'][0]
        y[count+2,0] = playerMap[c+'1'][4]
        y[count+3,0] = playerMap[c+'2'][1]
        y[count+4,0] = playerMap[c+'2'][4]
        y[count+5,0] = playerMap[c+'3'][2]
        y[count+6,0] = playerMap[c+'3'][4]
        y[count+7,0] = playerMap[c+'4'][3]
        y[count+8,0] = playerMap[c+'4'][4]
        y[count+9,0] = playerMap[c+'P'][4]
        y[count+10,0] = playerMap[c+'P'][0]
        y[count+11,0] = playerMap[c+'P'][1]
        y[count+12,0] = playerMap[c+'P'][2]
        y[count+13,0] = playerMap[c+'P'][3]
        count+=13

    e = np.zeros((16))
    e[0]=1

    env = gp.Env(empty=True)
    env.setParam("OutputFlag",0)
    env.start()

    m = gp.Model("br",env=env)

    # create variables
    xx = m.addMVar(40, ub=1.0, lb = 0.0)
    q = m.addMVar(16, lb=-float('inf'))

    # create objective
    m.setObjective(np.matmul(A,y).T @ xx, GRB.MAXIMIZE)
    # add constraints
    m.addConstr(E @ xx == e)
    m.addConstr(q[0] == epsilon-V_PRIME)
    m.addConstr(A.T @ xx >= -F.T@q)
    m.addConstr(xx >= 0) 

    m.optimize()

    brVector = abs(xx.X)

    count = 0
    for c in kCards:
        brM[c+''][0] = round(brVector[count+1],8) #1
        brM[c+''][1] = round(brVector[count+2],8) #2
        brM[c+''][2] = round(brVector[count+3],8) #3
        brM[c+''][3] = round(brVector[count+4],8) #4
        brM[c+''][4] = round(abs(1-(brVector[count+1]+brVector[count+2]+brVector[count+3]+brVector[count+4])),8)
        temp = abs(brM[c+''][4])
        if temp == 0:
            temp = 1
        brM[c+'P1'][0] = round(brVector[count+6]/temp,8)
        brM[c+'P1'][4] = abs(1-brM[c+'P1'][0])
        brM[c+'P2'][1] = round(brVector[count+8]/temp,8)
        brM[c+'P2'][4] = abs(1-brM[c+'P2'][1])
        brM[c+'P3'][2] = round(brVector[count+10]/temp,8)
        brM[c+'P3'][4] = abs(1-brM[c+'P3'][2])
        brM[c+'P4'][3] = round(brVector[count+12]/temp,8)
        brM[c+'P4'][4] = abs(1-brM[c+'P4'][3])
        count+=13
    return brM

def calcMatrices(A, M, playerMap, wrt):
    # Pass in A, E or F
    kCards = ['A','B','C']
    brM = playerMap
    if (wrt == 0):
        y = np.zeros((40,1))
        count = 0
        y[0,0]=1
        for c in kCards:
            y[count+1,0] = playerMap[c+'1'][0]
            y[count+2,0] = playerMap[c+'1'][4]
            y[count+3,0] = playerMap[c+'2'][1]
            y[count+4,0] = playerMap[c+'2'][4]
            y[count+5,0] = playerMap[c+'3'][2]
            y[count+6,0] = playerMap[c+'3'][4]
            y[count+7,0] = playerMap[c+'4'][3]
            y[count+8,0] = playerMap[c+'4'][4]
            y[count+9,0] = playerMap[c+'P'][4]
            y[count+10,0] = playerMap[c+'P'][0]
            y[count+11,0] = playerMap[c+'P'][1]
            y[count+12,0] = playerMap[c+'P'][2]
            y[count+13,0] = playerMap[c+'P'][3]
            count+=13
        E = M
        e = np.zeros(16)
        e[0]=1

        res = linprog(-np.matmul(A,y), A_eq=E, b_eq=e)
        
        brVector = abs(res.x)

        count = 0
        for c in kCards:
            brM[c+''][0] = brVector[count+1]
            brM[c+''][1] = brVector[count+2]
            brM[c+''][2] = brVector[count+3]
            brM[c+''][3] = brVector[count+4]
            brM[c+''][4] = abs(1-(brVector[count+1]+brVector[count+2]+brVector[count+3]+brVector[count+4])) 
            temp = abs(brM[c+''][4])
            if temp == 0:
                temp = 1
            brM[c+'P1'][0] = brVector[count+6]/temp
            brM[c+'P1'][4] = abs(1-brM[c+'P1'][0])
            brM[c+'P2'][1] = brVector[count+8]/temp
            brM[c+'P2'][4] = abs(1-brM[c+'P2'][1])
            brM[c+'P3'][2] = brVector[count+10]/temp
            brM[c+'P3'][4] = abs(1-brM[c+'P3'][2])
            brM[c+'P4'][3] = brVector[count+12]/temp
            brM[c+'P4'][4] = abs(1-brM[c+'P4'][3])
            count+=13
    else:
        B = A
        x = np.zeros((40,1))
        count = 0
        x[0,0]=1
        for c in kCards:
            x[count+1,0] = playerMap[c+''][0]
            x[count+2,0] = playerMap[c+''][1]
            x[count+3,0] = playerMap[c+''][2]
            x[count+4,0] = playerMap[c+''][3]
            x[count+5,0] = playerMap[c+''][4]
            x[count+6,0] = playerMap[c+'P1'][0]*playerMap[c+''][4]
            x[count+7,0] = playerMap[c+'P1'][4]*playerMap[c+''][4]
            x[count+8,0] = playerMap[c+'P2'][1]*playerMap[c+''][4]
            x[count+9,0] = playerMap[c+'P2'][4]*playerMap[c+''][4]
            x[count+10,0] = playerMap[c+'P3'][2]*playerMap[c+''][4]
            x[count+11,0] = playerMap[c+'P3'][4]*playerMap[c+''][4]
            x[count+12,0] = playerMap[c+'P4'][3]*playerMap[c+''][4]
            x[count+13,0] = playerMap[c+'P4'][4]*playerMap[c+''][4]
            count+=13

        F = M
        f = np.zeros((16,1))
        f[0,0]=1
        res = linprog(-np.matmul(np.transpose(B),x), A_eq=F, b_eq=f)

        brVector = res.x

        count = 0
        for c in kCards:
            brM[c+'1'][0] = brVector[count+1]
            brM[c+'1'][4] = brVector[count+2]
            brM[c+'2'][1] = brVector[count+3]
            brM[c+'2'][4] = brVector[count+4]
            brM[c+'3'][2] = brVector[count+5]
            brM[c+'3'][4] = brVector[count+6]
            brM[c+'4'][3] = brVector[count+7]
            brM[c+'4'][4] = brVector[count+8]
            brM[c+'P'][4] = brVector[count+9]
            brM[c+'P'][0] = brVector[count+10]
            brM[c+'P'][1] = brVector[count+11]
            brM[c+'P'][2] = brVector[count+12]
            brM[c+'P'][3] = brVector[count+13]
            count+=13
    return brM

def calcEv(firstPlayerProflie, secondPlayerProflie, cards, history, currentPlayer):
    if KuhnPoker.terminalState(history):
        return KuhnPoker.calcPayoff(history, cards)
    currentCard = cards[currentPlayer]
    nextPlayer = (currentPlayer + 1) % 2
    if currentPlayer == 0:
        strat = firstPlayerProflie[currentCard + history]
    else:
        strat = secondPlayerProflie[currentCard + history]
    
    if history not in ['','P']:
        maxBet = re.search(r'\d+', history).group()
        flag = False
    else:
        flag = True

    nextUtil = np.zeros(len(KuhnPoker.Actions))
    for i,action in enumerate(KuhnPoker.Actions):
        if flag or (maxBet in history and (maxBet == action or 'P' == action)): #Avoiding analysis of an impossible bet scenario
            nextUtil[i] = calcEv(firstPlayerProflie, secondPlayerProflie, cards, history + action, nextPlayer)
        else:
            nextUtil[i] = 0
    return -np.dot(strat, nextUtil) 

def ev(firstPlayerProflie, secondPlayerProflie):
    exp = 0
    for c in itertools.permutations(KuhnPoker.cards, 2):
        exp += 1/6 * calcEv(firstPlayerProflie, secondPlayerProflie, c, '', 0)
    return exp

def EEFEWP(players, history, cards, k, t):
    me = players[0]
    opp = players[1]
    brp = calcMatrices(A, E, copy.deepcopy(opp.stratProfile), 0)
    brTobrp = calcMatrices(-A, F, copy.deepcopy(brp), 1)
    exp = ev(brp, brTobrp)
    e = V_PRIME - exp
    if (1000-t+1)*e <= k:
        pi = Player(brp)
        pi.card = cards[0]
    else:
        pi = me
    action = pi.getAction(history)
    return action, pi

def testDriver(p1Strat,p2Strat,dynamic, iterations):
    np.random.seed()
    global V_PRIME, A, E, F
    A,E,F = initBRmatrices(p1Strat.copy(),p2Strat.copy())
    V_PRIME = ev(p1Strat,calcMatrices(-A, F, copy.deepcopy(p1Strat), 1))
    noExploiting = False
    ogModel = copy.deepcopy(p1Strat)
    m = copy.deepcopy(p1Strat)
    c = {'C': np.array([0, 0, 0, 0, 0]), 'C1': np.array([0, 0, 0, 0, 0]), \
        'C2': np.array([0, 0, 0, 0, 0]), 'C3': np.array([0, 0, 0, 0, 0]), \
        'C4': np.array([0, 0, 0, 0, 0]), 'CP': np.array([0, 0, 0, 0, 0]), \
        'CP1': np.array([0, 0, 0, 0, 0]), 'CP2': np.array([0, 0, 0, 0, 0]), \
        'CP3': np.array([0, 0, 0, 0, 0]), 'CP4': np.array([0, 0, 0, 0, 0]), \
        'B': np.array([0, 0, 0, 0, 0]), 'B1': np.array([0, 0, 0, 0, 0]), \
        'B2': np.array([0, 0, 0, 0, 0]), 'B3': np.array([0, 0, 0, 0, 0]), \
        'B4': np.array([0, 0, 0, 0, 0]), 'BP': np.array([0, 0, 0, 0, 0]), \
        'BP1': np.array([0, 0, 0, 0, 0]), 'BP2': np.array([0, 0, 0, 0, 0]), \
        'BP3': np.array([0, 0, 0, 0, 0]), 'BP4': np.array([0, 0, 0, 0, 0]), \
        'A': np.array([0, 0, 0, 0, 0]), 'A1': np.array([0, 0, 0, 0, 0]), \
        'A2': np.array([0, 0, 0, 0, 0]), 'A3': np.array([0, 0, 0, 0, 0]), \
        'A4': np.array([0, 0, 0, 0, 0]), 'AP': np.array([0, 0, 0, 0, 0]), \
        'AP1': np.array([0, 0, 0, 0, 0]), 'AP2': np.array([0, 0, 0, 0, 0]), \
        'AP3': np.array([0, 0, 0, 0, 0]), 'AP4': np.array([0, 0, 0, 0, 0])}
    me = Player(p1Strat.copy())
    opp = Player(p2Strat.copy())
    model = Player(m.copy())
    players = {0:me, 1:model}
    if (dynamic):
        brStratProfile = calcMatrices(-A, F, copy.deepcopy(p1Strat), 1)
    times = 1000
    totalWinnings = 0
    k = 0 
    for i in range(times):
        players = {0:me, 1:model}
        history = ''
        cards = KuhnPoker.deal(players)
        opp.card = cards[1]
        currentPlayer = 0
        while not KuhnPoker.terminalState(history):
            if (dynamic):
                if (i>100):
                    map1 = pi.stratProfile['C']
                    map2 = me.stratProfile['C']
                    if not (map1 == map2).all():
                        opp = Player(calcMatrices(-A, F, copy.deepcopy(pi.stratProfile), 1))
                    else:
                        opp = Player(brStratProfile)
                    opp.card = cards[1]
            if currentPlayer == 1:
                a = opp.getAction(history)
                oppAction = a
            elif noExploiting:
                a = me.getAction(history)
                pi = me
            else:
                a, pi = EEFEWP({0:me, 1:model}, history, cards, k)
            currentPlayer = (currentPlayer+1)%2
            history += a
        oppCard = cards[1]
        key = oppCard + history[0]
        mapp = np.zeros(5)
        if oppAction == 'P':
            val = 4
        else:
            val = int(oppAction)-1
        mapp[val] = 1
        c[key][val] += 1
        x=5
        updatedAction = [(ogModel[key][0]*x + c[key][0])/(x+sum(c[key])), (ogModel[key][1]*x + c[key][1])/(x+sum(c[key])), (ogModel[key][2]*x + c[key][2])/(x+sum(c[key])), (ogModel[key][3]*x + c[key][3])/(x+sum(c[key])), (ogModel[key][4]*x + c[key][4])/(x+sum(c[key]))]
        model.stratProfile[key] = updatedAction
        tau = calcMatrices(-A, F, copy.deepcopy(pi.stratProfile), 1)
        tau[key] = mapp
        exp = ev(pi.stratProfile, tau)
        k += exp - V_PRIME
        k = abs(k)
        payoff = KuhnPoker.calcPayoff(history, cards)
        if (len(history) % 2) == 1:
            payoff = -payoff
        totalWinnings += payoff
    return totalWinnings/times

def multiPro(p1Strat,p2Strat,dynamic):
    n = 40000
    pool = multiprocessing.Pool()
    processes = [pool.apply_async(testDriver, args=(p1Strat, p2Strat, dynamic, iterations),) for iterations in range(1,n+1)]
    result = [p.get() for p in processes]
    totalPayoff = 0
    for i in result:
        totalPayoff+=i
    print(f"Total payoff: {(totalPayoff)/n}")
    print(f"95% Confidence interval: {1.96*(np.std(result))/np.sqrt(n)}")

if __name__ == '__main__':
    np.set_printoptions(precision=6, floatmode='fixed', suppress=True)

    nash = {'C': np.array([0.166668, 0.000000, 0.000000, 0.000000, 0.833332]), 'C1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
        'C2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'C3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
        'C4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP': np.array([0.333364, 0.000000, 0.000000, 0.000000, 0.666636]), \
        'CP1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
        'CP3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
        'B': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'B1': np.array([0.333328, 0.000000, 0.000000, 0.000000, 0.666672]), \
        'B2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'B3': np.array([0.000000, 0.000000, 0.111131, 0.000000, 0.888869]), \
        'B4': np.array([0.000000, 0.000000, 0.000000, 0.083326, 0.916674]), 'BP': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
        'BP1': np.array([0.499985, 0.000000, 0.000000, 0.000000, 0.500015]), 'BP2': np.array([0.000000, 0.249968, 0.000000, 0.000000, 0.750032]), \
        'BP3': np.array([0.000000, 0.000000, 0.166658, 0.000000, 0.833342]), 'BP4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
        'A': np.array([0.500033, 0.000000, 0.000000, 0.000000, 0.499967]), 'A1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), \
        'A2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), 'A3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), \
        'A4': np.array([0.000000, 0.000000, 0.000000, 1.000000, 0.000000]), 'AP': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), \
        'AP1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), 'AP2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), \
        'AP3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), 'AP4': np.array([0.000000, 0.000000, 0.000000, 1.000000, 0.000000])}
    
    oneBetNash = {'C': np.array([0.025000, 0.025000, 0.025000, 0.025000, 0.900000]), 'C1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'C2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'C3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'C4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP': np.array([1/12, 1/12, 1/12, 1/12, 2/3]), \
            'CP1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'CP3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'B': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'B1': np.array([1/3, 0.000000, 0.000000, 0.000000, 2/3]), \
            'B2': np.array([0.000000, 1/3, 0.000000, 0.000000, 2/3]), 'B3': np.array([0.000000, 0.000000, 1/3, 0.000000, 2/3]), \
            'B4': np.array([0.000000, 0.000000, 0.000000, 1/3, 2/3]), 'BP': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'BP1': np.array([.1+1/3, 0.000000, 0.000000, 0.000000, 2/3-.1]), 'BP2': np.array([0.000000, .1+1/3,0.000000 ,0.000000 , 2/3-.1]), \
            'BP3': np.array([0.000000, 0.000000, .1+1/3, 0.000000, 2/3-.1]), 'BP4': np.array([0.000000, 0.000000, 0.000000, .1+1/3, 2/3-.1]), \
            'A': np.array([0.075000, 0.075000, 0.075000, 0.075000, 0.700000]), 'A1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), \
            'A2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), 'A3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), \
            'A4': np.array([0.000000, 0.000000, 0.000000, 1.000000,0.000000 ]), 'AP': np.array([1/4, 1/4, 1/4, 1/4, 0.000000]), \
            'AP1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), 'AP2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), \
            'AP3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), 'AP4': np.array([0.000000, 0.000000, 0.000000, 1.000000, 0.000000])}
   
    twoBetNash = {'C': np.array([0.073910, 0.073910, 0.000000, 0.000000, 0.852180]), 'C1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'C2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'C3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'C4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP': np.array([0.083310, 0.083310, 0.083310, 0.083310, 0.666760]), \
            'CP1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'CP3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'B': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'B1': np.array([0.334128, 0.000000, 0.000000, 0.000000, 0.665872]), \
            'B2': np.array([0.000000, 0.334128, 0.000000, 0.000000, 0.665872]), 'B3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'B4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'BP': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'BP1': np.array([0.481157, 0.000000, 0.000000, 0.000000, 0.518843]), 'BP2': np.array([0.000000, 0.481157,0.000000 ,0.000000 , 0.518843]), \
            'BP3': np.array([0.000000, 0.000000, 0.117976, 0.000000, 0.882024]), 'BP4': np.array([0.000000, 0.000000, 0.000000, 0.117976, 0.882024]), \
            'A': np.array([0.110699, 0.110699, 0.110699, 0.110699, 0.557204]), 'A1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), \
            'A2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), 'A3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), \
            'A4': np.array([0.000000, 0.000000, 0.000000, 1.000000,0.000000 ]), 'AP': np.array([0.499464, 0.499464, 0.000536, 0.000536, 0.000000]), \
            'AP1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), 'AP2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), \
            'AP3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), 'AP4': np.array([0.000000, 0.000000, 0.000000, 1.000000, 0.000000])}

    threeBetNash = {'C': np.array([0.133152, 0.000000, 0.000000, 0.000000, 0.866848]), 'C1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'C2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'C3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'C4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP': np.array([0.333294, 0.000705, 0.000705, 0.000000, 0.665296]), \
            'CP1': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'CP3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'CP4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'B': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'B1': np.array([0.328036, 0.000000, 0.000000, 0.000000, 0.671964]), \
            'B2': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'B3': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'B4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), 'BP': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'BP1': np.array([0.467958, 0.000000, 0.000000, 0.000000, 0.532042]), 'BP2': np.array([0.000000, 0.108048, 0.000000 ,0.000000 , 0.891952]), \
            'BP3': np.array([0.000000, 0.000000, 0.108048, 0.000000, 0.891952]), 'BP4': np.array([0.000000, 0.000000, 0.000000, 0.000000, 1.000000]), \
            'A': np.array([0.401968, 0.000000, 0.000000, 0.000000, 0.598032]), 'A1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), \
            'A2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), 'A3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), \
            'A4': np.array([0.000000, 0.000000, 0.000000, 1.000000,0.000000 ]), 'AP': np.array([0.995966, 0.002017, 0.002017, 0.000000, 0.000000]), \
            'AP1': np.array([1.000000, 0.000000, 0.000000, 0.000000, 0.000000]), 'AP2': np.array([0.000000, 1.000000, 0.000000, 0.000000, 0.000000]), \
            'AP3': np.array([0.000000, 0.000000, 1.000000, 0.000000, 0.000000]), 'AP4': np.array([0.000000, 0.000000, 0.000000, 1.000000, 0.000000])}

    closeNash = {'C': np.array([0.167320, 0.010000, 0.010000, 0.010000, 0.802680]), 'C1': np.array([0.010000, 0.000000, 0.000000, 0.000000, 0.990000]), \
            'C2': np.array([0.000000, 0.040000, 0.000000, 0.000000, 0.960000]), 'C3': np.array([0.000000, 0.000000, 0.050000, 0.000000, 0.950000]), \
            'C4': np.array([0.000000, 0.000000, 0.000000, 0.07000000, 0.930000]), 'CP': np.array([0.352397, 0.010425, 0.020000, 0.000000, 0.617178]), \
            'CP1': np.array([0.020000, 0.000000, 0.000000, 0.000000, 0.980000]), 'CP2': np.array([0.000000, 0.060000, 0.000000, 0.000000, 0.940000]), \
            'CP3': np.array([0.000000, 0.000000, 0.030000, 0.000000, 0.970000]), 'CP4': np.array([0.000000, 0.000000, 0.000000, 0.080000, 0.920000]), \
            'B': np.array([0.030000, 0.010000, 0.020000, 0.020000, 0.920000]), 'B1': np.array([0.371425, 0.000000, 0.0000000, 0.0000000, 0.628575]), \
            'B2': np.array([0.000000, 0.015000, 0.000000, 0.000000, 0.985000]), 'B3': np.array([0.000000, 0.000000, 0.060000, 0.000000, 0.940000]), \
            'B4': np.array([0.000000, 0.000000, 0.000000, 0.020000, 0.9800000]), 'BP': np.array([0.030000, 0.020000, 0.040000, 0.010000, 0.900000]), \
            'BP1': np.array([0.463551, 0.000000, 0.000000, 0.000000, 0.536449]), 'BP2': np.array([0.000000, 0.143591,0.000000 ,0.000000 , 0.856409]), \
            'BP3': np.array([0.000000, 0.000000, 0.010000, 0.000000, 0.990000]), 'BP4': np.array([0.000000, 0.000000, 0.000000, 0.100000, 0.900000]), \
            'A': np.array([0.412099, 0.000000, 0.000000, 0.000000, 0.587901]), 'A1': np.array([0.940000, 0.000000, 0.000000, 0.000000, 0.060000]), \
            'A2': np.array([0.000000, 0.920000, 0.000000, 0.000000, 0.080000]), 'A3': np.array([0.000000, 0.000000, 0.970000, 0.000000, 0.030000]), \
            'A4': np.array([0.000000, 0.000000, 0.000000, 0.950000,0.050000 ]), 'AP': np.array([0.918493, 0.021507, 0.030000, 0.020000, 0.010000]), \
            'AP1': np.array([0.910000, 0.000000, 0.000000, 0.000000, 0.090000]), 'AP2': np.array([0.000000, 0.940000, 0.000000, 0.000000, 0.060000]), \
            'AP3': np.array([0.000000, 0.000000, 0.990000, 0.000000, 0.010000]), 'AP4': np.array([0.000000, 0.000000, 0.000000, 0.920000, 0.080000])}

    randomStrat = {'C': np.array([0.2, 0.2, 0.2, 0.2, 0.2]), 'C1': np.array([0.5, 0.0, 0.0, 0.0, 0.5]), \
            'C2': np.array([0.0, 0.5, 0.0, 0.0, 0.5]), 'C3': np.array([0.0, 0.0, 0.5, 0.0, 0.5]), \
            'C4': np.array([0.0, 0.0, 0.0, 0.5, 0.5]), 'CP': np.array([0.2, 0.2, 0.2, 0.2, 0.2]), \
            'CP1': np.array([0.5, 0.0, 0.0, 0.0, 0.5]), 'CP2': np.array([0.0, 0.5, 0.0, 0.0, 0.5]), \
            'CP3': np.array([0.0, 0.0, 0.5, 0.0, 0.5]), 'CP4': np.array([0.0, 0.0, 0.0, 0.5, 0.5]), \
            'B': np.array([0.2, 0.2, 0.2, 0.2, 0.2]), 'B1': np.array([0.5, 0.0, 0.0, 0.0, 0.5]), \
            'B2': np.array([0.0, 0.5, 0.0, 0.0, 0.5]), 'B3': np.array([0.0, 0.0, 0.5, 0.0, 0.5]), \
            'B4': np.array([0.0, 0.0, 0.0, 0.5, 0.5]), 'BP': np.array([0.2, 0.2, 0.2, 0.2, 0.2]), \
            'BP1': np.array([0.5, 0.0, 0.0, 0.0, 0.5]), 'BP2': np.array([0.0, 0.5, 0.0, 0.0, 0.5]), \
            'BP3': np.array([0.0, 0.0, 0.5, 0.0, 0.5]), 'BP4': np.array([0.0, 0.0, 0.0, 0.5, 0.5]), \
            'A': np.array([0.2, 0.2, 0.2, 0.2, 0.2]), 'A1': np.array([0.5, 0.0, 0.0, 0.0, 0.5]), \
            'A2': np.array([0.0, 0.5, 0.0, 0.0, 0.5]), 'A3': np.array([0.0, 0.0, 0.5, 0.0, 0.5]), \
            'A4': np.array([0.0, 0.0, 0.0, 0.5, 0.5]), 'AP': np.array([0.2, 0.2, 0.2, 0.2, 0.2]), \
            'AP1': np.array([0.5, 0.0, 0.0, 0.0, 0.5]), 'AP2': np.array([0.0, 0.5, 0.0, 0.0, 0.5]), \
            'AP3': np.array([0.0, 0.0, 0.5, 0.0, 0.5]), 'AP4': np.array([0.0, 0.0, 0.0, 0.5, 0.5])}
    A,E,F = initBRmatrices(nash2.copy(),nash2.copy())
    print(ev(nash2,calcMatrices(-A, F, copy.deepcopy(nash2), 1)))
    print(ev(calcMatrices(A, E, copy.deepcopy(nash2), 0),nash2))
    print(ev(nash2,nash2))
    if (sys.argv[1] == '0'):
        if (sys.argv[2] == '0'):
            multiPro(nash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(nash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(nash, randomStrat, False)
        else:
            multiPro(nash, randomStrat, True)
    elif (sys.argv[1] == '1'):
        if (sys.argv[2] == '0'):
            multiPro(threeBetNash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(threeBetNash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(threeBetNash, randomStrat, False)
        else:
            multiPro(threeBetNash, randomStrat, True)
    elif (sys.argv[1] == '2' ):
        if (sys.argv[2] == '0'):
            multiPro(twoBetNash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(twoBetNash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(twoBetNash, randomStrat, False)
        else:
            multiPro(twoBetNash, randomStrat, True)
    else:
        if (sys.argv[2] == '0'):
            multiPro(oneBetNash, nash, False)
        elif (sys.argv[2] == '1'):
            multiPro(oneBetNash, closeNash, False)
        elif (sys.argv[2] == '2'):
            multiPro(oneBetNash, randomStrat, False)
        else:
            multiPro(oneBetNash, randomStrat, True)